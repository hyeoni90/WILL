# Back To The Basic Java 
> Java 핵심 요약 노트, 빠르게 훑어보는 자바 프로그래밍 도서를 읽고 정리한 내용 입니다. 
 
## OOP 주요 특징 4가지
- 상속성 (Inheritance) 
- 캡슐화 (Encapsulation) 
- 추상화 (Abstraction) 
- 다형성 (Polymorphism)

### 상속 (Inheritance)
> 상속이란 상위 클래스(부모 클래스)의 특징을 하위 클래스(자식 클래스)가 모두 물려받는 것 

`extends` 키워드를 통해서 상속이란 다른 클래스의 멤버 변수나 메소드를 자신의 것처럼 쓸 수 있는 특성

### 캡슐화 (Encapsulation)
> 캡슐화란 ‘실제 기능’은 숨기고 ‘접근할 방법’만 노출하는 것

프로그램의 복잡도를 줄이는 데도 사용되며,
캡슐화를 이용하여 알 필요가 없는 정보를 숨겨 프로그램의 복잡도를 제어 할 수 있는 것. 이러한 정보의 노출 여부를 은닉성.
자바는 캡슐화를 위해 default, public, private, protected 등 네 가지 타입의 접근 제한자 (Access Modifier)를 제공한다.

```text
- public: 모든 객체에서 접근 가능
- protected: 상속 관계의 객체만 접근 가능, 일반 객체는 접근 불가
- default: 같은 패키지의 객체만 접근 가능
- private: 외부 객체에서 접근 불가
```
* private → default → protected → public

### 추상화 (Abstraction)
> 추상화는 객체의 공통적인 특징을 뽑아내는 과정이라고 할 수 있으며, 이를 이용하면 객체를 단순하게 표현하는 것이 가능해진다

* 객체를 추상화하는 과정
    - 객체들이 공통적으로 가지고 있는 개념을 추출
    - 공통 개념이 추출되면, 추출한 개념을 이용하여 최소한의 기능을 가진 상위 개념
      의 객체를 만든다.
    - 나머지 객체는 상위 개념의 객체를 상속받아 구현하는 형태로 변경  
    
### 다형성 (Polymorphism)
> 다형성은 객체 간의 ‘결합도`를 줄이기 위해 OOP에 도입된 개념으로,
> 
> 이를 이용하면 객체 간의 결합도를 약하게 만듦으로써 객체 간 연결을 유연하게 할 수 있다.

다형성을 이용하는 가장 큰 이유는 객체 간의 결합도를 줄이기 위해서다.
때문에 다형성을 이용해 코드를 작성하면, 새로운 하위 클래스를 추가하더라 도 기존의 코드를 변경할 필요가 없다.

## Object 클래스
### equals() 메서드
객체 자체는 메모리의 힙(Heap) 영역에 생성 되고 해당 객체를 호출 할 수 있도록 이 영역의 주소 값만 제공한다.
* 객체를 비교할 수 있다.
* 단순히 <u>객체 레퍼런스 값만을 비교</u>하며, 같은 객체라도 새로운 메모리 공간에 생성되면 false 값을 리턴한다.

cf) `==` 비교 연산자는 Primitive 데이터 타입만을 비교할 수 있으며 객체는 비교할 수 없다.

```text
💡 객체의 값을 비교해서 객체의 동일 여부를 알아봐야 하는 클래스는 반드시 equals() 메소드를 오버라이딩해야 한다.

equals() 메소드를 오버라이딩해야 하는 상황에서 오버라이딩 하지 않아도 컴파일 에러는 발생하지 않는다.
상황에 따라 프로그 램이 비정상적으로 동작할 수 있기 때문에 설계 의도를 파악하고 equals() 메소드 오버라이딩 여부를 반드시 확인해야 한다.
```

아래와 같은 경우라면 굳이 equals() 메소드를 오버라이딩하지 않아도 된다.
- 클래스의 인스턴스가 프로세스 내에서 하나만 생성되는 경우
- 상속 관계의 부모 클래스에 이미 equals() 메소드가 구현되어 있는 경우

### hashCode() 메서드
* hashCode() 메소드를 이용하여 <u>객체의 고유한 값</u>을 구할 수 있다.
* HashTable 이나 HashMap 같은 `해싱 알고리즘을 사용하는 자료 구조에 주로 사용`한다.
* 객체의 메모리 주소를 바탕으로 4바이트의 고유 한 숫자 값을 리턴하며, 메모리 주소가 다른 객체는 같은 hashCode 값(해시 코드값)을 가질 수 없다.

💡 equals() 메소드를 오버라이딩 할 경우, hashCode() 메소드도 같이 오버라이딩 해야 한다.
(**같은 객체라면 해시 값 역시 반드시 같아야 하기 때문**)

만약, equals() 메소드만 오버라이딩하여 구현하고 hashCode() 메소드를 오버라이딩 하지 않는다면, 해시 기반의 자료 구조를 사용할 때 올바르게 동작하지 않는다.


# Reference
- [Java 핵심 요약 노트, 빠르게 훑어보는 자바 프로그래밍](http://book.interpark.com/amway/product/BookDisplay.do?_method=detail&sc.shopNo=0000400000&sc.dispNo=028023018004003&sc.prdNo=214200579)
