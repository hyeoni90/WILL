# DDD (Domain-Driven-Design) 
> DDD start! 도메인 주도 설계 구현과 핵심 개념 익히기를 읽으며 정리한 내용 입니다.

## 1. 도메인 모델 시작
* 하나의 도메인은 하위의 여러 도메인으로 나눌 수 있다.
* 도메인 마다 고정된 하위 도메인이 존재하는 것은 아니다.
* 도메인을 어떻게 구성할지 여부는 상황에 따라 달라진다.
![도메인은 여러 하위 도메인으로 구성된다.](./images/domain-configuration.png)

### 도메인 모델
기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현 한 것.
즉, 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다.

도메인 모델 표현 방식
- 객체 기반 주문 도메인 모델링 (주요 데이터 구성을 파악하고 기능과 데이터 보여주기 적합)
- 클래스 다이어그램, 상태 다이어그램을 이용한 상태 모델링
- 이외에도 그래프 이용한 모델링 등

### 도메인 모델 패턴

#### 계층(아키텍처) 구성

|계층(Layer)|설명
|----|--------------------------------------------------------|
|사용자인터페이스(UI) 또는 표현(Presentation)|사용자의 요청을 처리하고 정보를 보여준다.(Controller)|
|응용(Application|사용자가 요청한 기능을 실행 / 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해 기능을 실행 |
|도메인|시스템이 제공할 도메이느이 규칙을 구현 (Aggregate, Entity)|
|인프라스트럭처(Infrastructure)|데이터베이스나 메세징 시스템과 같은 외부 시스템과의 연동 처리(DB 연동, Message Queue, SMTP Email, External API)|

* 도메인 모델 패턴
    * 해당 도메인에 규칙을 구현한 코드가 도메인 계층에 위치하고, 이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴
        (서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할)
    * 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하므로, 규칙이 바뀌거나 확장해야할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있다.
    
> cf. 트랜잭션 스크립트 패턴
> 
> 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 비즈니스 로직을 처리하는 것.
    
#### 도메인 모델 도출
기획서, 유스 케이스, 사용자 스토리와 같은 요구 사항과 관련좌의 대화를 통해 도메인을 이해하는 것이 첫 시작!
도메인 모델링 때 모델을 구성하는 `핵심 구성요소`, `규칙`, `기능` 을 찾아야 한다.

#### 엔티티와 밸류
도메인을 올바르게 설계하고 구현하기 위해서는 엔티티와 밸류의 차이를 명확하게 이해하고 제대로 구분하는 것이 도메인을 구현하는데 있어 중요!

##### 엔티티
식별자를 갖는다. (각 엔티티는 서로 다른 식별자를 갖는다. ex. 주문은 각 주문마다 주문번호가 다르며 `주문번호` 가 식별자가 됨)

식별자 생성은 사용 기술과 특징에 따라 다르나 흔히 아래와 같은 방식을 사용한다.
(⚠ 같은 시간에 동시에 식별자를 생성할 때 같은 식별자가 만들어지면 안된다.)

- 특정 규칙에 따라 생성
- UUID 사용
- 값을 직접 입력
- 일련번호 사용(Oracle 시퀀스나 MySQL 자동 증가 컬럼 사용)

##### 밸류
개념적으로 완전한 하나를 표현할 때 사용 (ex. 주소 = address1, address2, zipCode)

장점) 
- 코드의 의미를 더 잘 이해할 수 있도록 한다. (개념적으로 표현된 것을 사용해 의미를 파악하기 쉬움)
- 밸류 타입을 위한 기능을 추가할 수 있다. 

밸류 객체의 데이터 변경할 때 기존 데이터 변경 보다 변경한 데이터를 갖는 새로운 밸류 객체 생성 방식 선호.
`불변 객체 (데이터 변경 기능을 제공하지 않는 타입)`로 구현하게 되면 보다 안전한 코드를 작성할 수 있다.
> 불변 객체는 참조 투명성과 스레드에 안전하다.

##### 도메인 모델에 set 메서드 넣지 않기
set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
또한, 도메인 객체 생성 시 완전한 상태가 아닐 수도 있다.
도메인 객체가 불완전한 상태로 사용되는 것 방지 하려면 생성자를 통해 필요한 데이터를 모두 받아야 한다.

## 2. 아키텍처 개요

### 계층 구조 아키텍처

```text
Application(service) -> Domain(entity) -> Infrastructure(DB, rule Engine, messaging)
Application(service) -> Infrastructure(DB, rule Engine, messaging)
Domain(entity) -> Infrastructure(DB, rule Engine, messaging)
```

* 특성상 상위 계층에서 하위 계층으로의 의존만 존재, 하위 게층은 상위 계층의 의존하지 않는다.
* 하지만, 구현의 편리함을 위해 계층 구조를 유연하게 적용한다. ex. 응용 계층은 도메인 계층에 의존하지만 외부 시스템과의 연동으 ㄹ위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 함.

✅ 인프라스트럭처에 의존하면, `테스트의 어려움` 과 `기능 확장의 어려움` 의 문제가 발생한다.

그렇다면.. 어떻게 해결할 수 있을까? 해결 방법은? `DIP 적용하는 것`

> DIP (Dependency Inversion Principle) : 의존성 역전의 법칙
> 상위 계층이 하위 계층에 의존하는 의존 관계를 역전(반전) 시킴으로써 상위 계층이 하위 계층의 구현으로 부터 독립되게 할 수 있다.
> 추상화 하여 관계를 느슨하게 만들고 확장에 유연하게 만든다. 
> 
> ex. DIP를 구현하는 기법 중 하나가 DI (Dependency Injection) 이다.

* DIP는 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.
* 실제 사용할 저수준 구현 객체는 의존 주입을 이용해서 전달 받을 수 있다. 


* DIP 적용할 때 중요한 점
    * 하위 기능을 추상화한 인터페이스는 고수준 모둘 관점에서 도출한다. (추상화한 인터페이스가 고수준 모듈에 위치)

### 도메인 영역의 구성요소
* 도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심이 되는 로직을 구현한다.

|요소|설명
|----|--------------------------------------------------------|
|엔티티 (Entity) | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 도메인 모델의 테이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공 (회원, 상품 같ㅇ른 도메인의 고유한 개념 표현)|
|밸류 (Value) | 고유의 식별자를 갖지 않는 객체, 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용. (주소, 구매 금액을 위한 금액(Money) 같은 타입) |
|애그리거트 (Aggregate) | 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것. (주문 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체  => `주문 애그리거트`) |
|레파지토리 (Repository) | 도메인 모델의 영속성을 처리. (DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능 제공) |
|도메인 서비스 (Domain Service) | 특정 엔티티에 속하지 않는 도메인 로직 제공. 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다. (ex. `할인 금액 계산`  쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현해야 할 경우)  |

### 엔티티 (Entity) 와 밸류 (Value)
* 차이점
    * 도메인 모델의 엔티티: 데이터와 함께 도메인 기능을 함께 제공하는 객체 
        * 도메인 관점에서 기능을 구현하고 기능 구현을 `캡슐화` 해서 임의로 변경되는 것을 막는다.
        * 주문 엔티티의 경우, 주문 관련된 데이터 뿐 아니라 배송지 주소 변경을 위한 기능도 함께 제공
    * 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입으로 표현 가능 (밸류는 불편으로 구현 권장)
    
### 애그리거트 (Aggregate)
* 도메인 모델에서 전체 구조를 이해하고 복잡한 도메인 모델을 관리하는데 도움이 된다.

* 루트 엔티티
    * 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다. 
    * 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근하게 된다. 애그리거트 단위로 구현 -> 내부 구현을 숨겨 `캡슐화` 하도록 한다.
    * 도메인 로직에 맞게 애그리거트의 상태를 관리
